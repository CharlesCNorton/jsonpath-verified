# jsonpath-verified: Cure List

## Completed

1. Add a `_CoqProject` file and Makefile for reproducible builds. **Status:** done.
2. Split the single file into per-module files gated by the build system. **Status:** done via `JPV_Core.v`, `JPV_Formalization.v`, `JPV_Extensions.v`, `JPV_API_Extraction.v`, with facade `jsonpath_verified.v`.

## Remaining (RFC Completeness)

1. Replace the ASCII-first runtime with an end-to-end Unicode model across JSON values, JSONPath syntax, regex/string operations, and API surfaces; keep compatibility lemmas where needed. **Status:** done via `Unicode`, `UnicodeJSON`, `UnicodeJSONPath`, `UnicodeRegex`, `UnicodeExec`, and `UnicodeAPI`, including ASCII bridge conversions/lemmas.
2. Extend `JSONPathABNF` from the current core subset to full RFC 9535 grammar coverage, and implement a total parser for the full surface language. **Status:** done via extended `full_token` grammar (`abnf_full_selector`/`abnf_full_segment`/`abnf_full_query`) and parser stack (`parse_full_selector`, `parse_full_segment`, `parse_full_segments`, `parse_full_query` / `parse_surface_query`) with soundness theorem `parse_full_query_sound`.
3. Strengthen executable-relational correspondence from the current child-only/filter-free and linear fragments to the full query language (including filters) with precise order/permutation statements. **Status:** done via full-language bridge theorems in `JPV_Formalization` (`full_holds_reflection`, `full_selector_exec_exact`, `full_segment_exec_exact`, `full_query_exec_exact`, `full_query_exec_permutation`, `full_query_exec_paths_exact`, `full_query_exec_values_exact`, `full_filter_selector_exec_exact`).
4. Replace the conservative `Typing.wf_fexpr` gate with a precise, proved criterion (or full semantic proof path) that does not reject RFC-valid filter forms, and align API error behavior with that proof. **Status:** done via `TypingPrecise` (proved total/complete for queries) and API alignment theorems (`API.eval_checked_exact`, `API.eval_checked_never_notwf`, `UnicodeAPI.eval_checked_exact`, `UnicodeAPI.eval_checked_never_notwf`).

## Cure Sequence (Toward 10/10)

1. Build a concrete Unicode lexer from raw JSONPath strings to lexical tokens, with a total error model and location reporting. **Status:** done via `lex_surface`/`lex_surface_aux` with structured `lex_error` (`lex_err_pos`, `lex_err_kind`, `lex_err_char`) and full `surface_token` coverage.
2. Eliminate placeholder grammar tokens (`FTSlice`, `FTFilterExpr`) by parsing full slice/filter surface syntax from concrete token streams. **Status:** done via concrete slice/filter parsing (`parse_surface_slice_tail`, `parse_surface_fexpr_fuel`, `parse_surface_selector_fuel`) and token-level assembly (`parse_surface_query_tokens`).
3. Prove full parser completeness for the extended grammar and add an iff-style correctness theorem for the full parser (`sound + complete`). **Status:** done via parser correctness lemmas (`parse_full_query_sound`) and iff-style token/string correctness theorems for the concrete surface path (`parse_surface_query_tokens_correct`, `parse_surface_query_string_correct`).
4. Prove end-to-end string parsing correctness (`raw string -> AST`) against the formal ABNF relation, including lexer-parser composition. **Status:** done via `abnf_surface_string` and composition theorems (`parse_surface_query_string_sound`, `parse_surface_query_string_complete`, `parse_surface_query_string_correct`).
5. Enforce Unicode validity invariants (`codepoint_valid`) in runtime string/key representations and prove closure under parser/evaluator constructors. **Status:** done via `valid_ustring`/`vustring`, `uvalue_valid`/`unode_valid`, conversion-preservation lemmas (`of_ascii_value_valid`, `of_ascii_node_valid`), and lexer rejection of invalid codepoints (`LexInvalidCodepoint`).
6. Replace lossy Unicode->ASCII fallback conversion with a principled encoding/partial conversion API, and prove precise round-trip/simulation lemmas. **Status:** done via `codepoint_to_ascii_opt`, `ustring_to_ascii_opt`, `to_ascii_value_opt`/`to_ascii_node_opt`, with proofs (`codepoint_to_ascii_opt_sound`, `ascii_partial_roundtrip`, `ustring_to_ascii_opt_sound`, `to_ascii_value_opt_of_ascii`, `to_ascii_node_opt_of_ascii`).
7. Add a full-language direct semantic bridge from original relational semantics (`eval`, `aeval_rel`, `holds`) to executable semantics (`Exec.eval_exec`, `Exec.aeval`, `Exec.holds_b`) without wrapper-induced trivialization. **Status:** done via full-language bridge theorems in `JPV_Formalization` (`full_holds_reflection`, `full_selector_exec_exact`, `full_segment_exec_exact`, `full_query_exec_exact`, `full_filter_selector_exec_exact`).
8. Strengthen order/permutation theorems for unrestricted queries to be proven from the original relational rules, not by reflexive equality over wrapper relations. **Status:** done via unrestricted result-shape/order bridge theorems (`full_query_exec_permutation`, `full_query_exec_paths_exact`, `full_query_exec_values_exact`).
9. Replace permissive `TypingPrecise` acceptance with a discriminating, proved criterion that rejects exactly ill-typed/unsupported filter forms and accepts RFC-valid ones. **Status:** done via discriminating `TypingPrecise` checks (`wf_regex`, mutual `wf_aexpr`/`wf_fexpr`/`wf_selector`/`wf_segment`/`wf_query`) including comparator type-compatibility and zero-step slice rejection.
10. Rework API error contracts so `E_NotWF` is semantically meaningful (or remove it), and prove correspondence between decision procedures and emitted API errors. **Status:** done via API/UnicodeAPI correspondence lemmas (`eval_checked_exact` with `wf_query = true`, `eval_checked_notwf`, `eval_checked_notwf_iff`) tying emitted `E_NotWF` directly to failed well-formedness checks.

## Unforgiving Closure TODO (10/10 Only)

1. Replace wrapper-level bridge statements with direct theorems over original relations: prove `eval q J res <-> res = Exec.eval_exec q J` for the unrestricted language (not via `eval_exec_rel` wrapper constructors). **Done only if:** theorem is stated and proved directly from `eval`.
2. Replace wrapper-level `holds` bridge with direct reflection: prove `holds f n <-> Exec.holds_b f n = true` for all filters. **Done only if:** theorem mentions `holds` directly, not `holds_exec`.
3. Replace wrapper-level arithmetic bridge with direct reflection: prove `aeval_rel a v p <-> Exec.aeval a v = Some p`. **Done only if:** theorem mentions `aeval_rel` directly, not `aeval_rel_exec`.
4. Prove unrestricted permutation/order properties from original relational derivations (`eval`), not by rewriting from wrapper equalities. **Done only if:** proofs consume relational hypotheses and do not end in immediate `Permutation_refl` after wrapper inversion.
5. Formalize independent concrete-syntax relation for surface strings/tokens (separate from parser-as-definition wrappers), then prove parser soundness/completeness against that relation. **Done only if:** ABNF relation is inductive and parser correctness is non-definitional.
6. Prove lexer validity closure: every token emitted by `lex_surface` carries only valid codepoints (`codepoint_valid`) for identifier/string payloads. **Done only if:** theorem over `LexSurfaceOk toks` provides token-wise validity invariant.
7. Eliminate unconditional ASCII projection paths from semantics-critical APIs: expose only total-safe or partial (`option/result`) conversions where data loss is possible. **Done only if:** no lossy fallback remains in evaluation-facing API surface.
8. Strengthen Unicode round-trip guarantees: prove partial conversion completeness on exactly ASCII-compatible domain and explicit failure off-domain. **Done only if:** iff-style specification exists for `ustring_to_ascii_opt`.
9. Make `TypingPrecise` criterion semantically justified: prove soundness (accepted queries cannot trigger unsupported runtime cases) and targeted rejection witnesses for each rejected class. **Done only if:** both positive soundness and negative witness theorems exist.
10. Prove API error completeness/exclusivity: each `exec_error` corresponds to a precise logical predicate and predicates are disjoint where intended. **Done only if:** bidirectional theorems exist for every error constructor used by `eval_checked`/`eval_one_linear`.
11. Add regression theorem suite for RFC edge behavior (negative indices, slice step/sign, mixed-type comparisons, regex constructors) tied to exact expected outputs. **Done only if:** each edge case has a named theorem and no `Admitted`/`Axiom`.
12. Enforce zero-trust proof hygiene gate: repository must compile with no `Admitted` and no `Axiom` in project files. **Done only if:** automated check is wired and passing.
